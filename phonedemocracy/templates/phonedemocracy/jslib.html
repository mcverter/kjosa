var PUBLIC_WEBPASSWORD_SALT = '{{settings.VOTING_PUBLIC_SALT}}';
var PUBLIC_TEMP_WEBPASSWORD_SALT = '{{settings.VOTING_TEMP_PUBLIC_SALT}}';


var str2ab = function(str) {
  return (new TextEncoder("utf-8").encode(str));
}

function bits2hex(bits /*Uint8Array*/) {
  var final_hash = '';
  for (v of bits.values()) {
    var hex = v.toString(16);
    final_hash = (final_hash 
                  + ((hex.length == 2) ? hex : '0'+hex)
                 );
    //console.log(v, v.toString(16));
  }
  return final_hash;
}

function webPasswordToSymmetricKey(webpassword, callback) {
  pbkdf2Cycle(new TextEncoder("utf-8").encode(webpassword),
              PUBLIC_WEBPASSWORD_SALT, 4000,
              function(bits) {
                pbkdf2Cycle(bits,
                            PUBLIC_TEMP_WEBPASSWORD_SALT, 1000,
                            callback);
              });
}

function pbkdf2Cycle(password, salt, count, callback) {
  /*
    In python, identical to:
    import hashlib
    dk = hashlib.pbkdf2_hmac('sha256', password.encode('utf8'),
                        salt.encode('utf8'), count)
    return [dk[i] for i in range(8)]
   */

  window.crypto.subtle.importKey(
    "raw", //only "raw" is allowed
    //window.crypto.getRandomValues(new Uint8Array(16)), //your password
    password,
    {
        name: "PBKDF2",
    },
    true, //whether the key is extractable (i.e. can be used in exportKey)
    ["deriveKey", "deriveBits"] //can be any combination of "deriveKey" and "deriveBits"
  )
  .then(function(key){
      //returns a key object
      window.crypto.subtle.deriveBits(
        {
          "name": "PBKDF2",
          //"salt": window.crypto.getRandomValues(new Uint8Array(16)),
          "salt": new TextEncoder("utf-8").encode(salt),
          "iterations": count,
          "hash": {name: "SHA-256"}, //can be "SHA-1", "SHA-256", "SHA-384", or "SHA-512"
        },
        key, //your key from generateKey or importKey
        64 //the number of bits you want to derive
      )
        .then(function(bits){
          //returns the derived bits as an ArrayBuffer
          var result = new Uint8Array(bits);
          callback(result);
        })
   })
}

function encode_vote_code(issue_id, choice_id) {
  if (issue_id >= 65536 || choice_id >= 256) {
    throw Error("issue or choice id too large");
  }
  //0-255
  var iv = window.crypto.getRandomValues(new Uint8Array(1))[0];
  var codable_int = ((iv << 24) + (issue_id << 8) + choice_id);
  var first_16bits = codable_int >> 16;
  return [first_16bits, codable_int - (first_16bits << 16)];
}

function encode_vote_int(codable_int) {
  var base31 = 'abcdefghjkmnpqrstuvwxyz23456789';
  var char31s = [];
  for (var i=0; i<7; i++) {
    char31s.push(base31[codable_int % 31]);
    codable_int = parseInt(codable_int / 31);
  }
  return char31s.join('');
}

function encodeSpeckVote(key, issue_id, choice_id) {
  var text = encode_vote_code(parseInt(issue_id), parseInt(choice_id));
  var expanded = [];
  expandKey(key, expanded); //alters expanded
  encrypt(text, expanded); //alters text
  //same as (text[0] << 16) but doesn't loop around to negative values
  var codable_int = (text[0] * 65536) + text[1];
  return encode_vote_int(codable_int);
}

function speckTest() {
  var expanded = [];
  //each elt in key is a 16-bit number
  var key = [0,0,0,50];
  expandKey(key, expanded); //alters expanded
  var text = [0,0];
  encrypt(text, expanded); //alters text
  return text;
  //will be: [4565, 26980] which is same as python's output
}
