var PUBLIC_WEBPASSWORD_SALT = '{{settings.VOTING_PUBLIC_SALT}}';


var str2ab = function(str) {
  var buf = new ArrayBuffer(str.length); // 2 bytes for each char
  var bufView = new Uint8Array(buf);
  for (var i=0, strLen=str.length; strLen > i; i++) {
    bufView[i] = str.charCodeAt(i);
  }
  return buf;
}

function webPasswordToSymmetricKey(webpassword, callback) {
  /*
    In python, identical to:
    import hashlib
    dk = hashlib.pbkdf2_hmac('sha256', webpassword.encode('utf8'),
                        PUBLIC_WEBPASSWORD_SALT.encode('utf8'), 5000)
    return [dk[i] for i in range(8)]
   */

  window.crypto.subtle.importKey(
    "raw", //only "raw" is allowed
    //window.crypto.getRandomValues(new Uint8Array(16)), //your password
    new TextEncoder("utf-8").encode(webpassword),
    {
        name: "PBKDF2",
    },
    true, //whether the key is extractable (i.e. can be used in exportKey)
    ["deriveKey", "deriveBits"] //can be any combination of "deriveKey" and "deriveBits"
  )
  .then(function(key){
      //returns a key object
      window.crypto.subtle.deriveBits(
        {
          "name": "PBKDF2",
          //"salt": window.crypto.getRandomValues(new Uint8Array(16)),
          "salt": new TextEncoder("utf-8").encode(PUBLIC_WEBPASSWORD_SALT),
          "iterations": 5000,
          "hash": {name: "SHA-256"}, //can be "SHA-1", "SHA-256", "SHA-384", or "SHA-512"
        },
        key, //your key from generateKey or importKey
        64 //the number of bits you want to derive
      )
        .then(function(bits){
          //returns the derived bits as an ArrayBuffer
          var result = new Uint8Array(bits);
          callback(result);
        })
   })
}

function encode_vote_code(issue_id, choice_id) {
  if (issue_id >= 65536 || choice_id >= 256) {
    throw Error("issue or choice id too large");
  }
  //0-255
  var iv = window.crypto.getRandomValues(new Uint8Array(1))[0];
  var codable_int = ((iv << 24) + (issue_id << 8) + choice_id);
  var first_16bits = codable_int >> 16;
  return [first_16bits, codable_int - (first_16bits << 16)];
}

function encode_vote_int(codable_int) {
  var base31 = 'abcdefghjkmnpqrstuvwxyz23456789';
  var char31s = [];
  for (var i=0; i<7; i++) {
    char31s.push(base31[codable_int % 31]);
    codable_int = parseInt(codable_int / 31);
  }
  return char31s.join('');
}

function encodeSpeckVote(key, issue_id, choice_id) {
  var text = encode_vote_code(parseInt(issue_id), parseInt(choice_id));
  var expanded = [];
  expandKey(key, expanded); //alters expanded
  encrypt(text, expanded); //alters text
  //same as (text[0] << 16) but doesn't loop around to negative values
  var codable_int = (text[0] * 65536) + text[1];
  return encode_vote_int(codable_int);
}

function speckTest() {
  var expanded = [];
  //each elt in key is a 16-bit number
  var key = [0,0,0,50];
  expandKey(key, expanded); //alters expanded
  var text = [0,0];
  encrypt(text, expanded); //alters text
  return text;
  //will be: [4565, 26980] which is same as python's output
}
