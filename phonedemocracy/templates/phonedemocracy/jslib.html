var PUBLIC_WEBPASSWORD_SALT = '{{settings.VOTING_PUBLIC_SALT}}';

var str2ab = function(str) {
  var buf = new ArrayBuffer(str.length); // 2 bytes for each char
  var bufView = new Uint8Array(buf);
  for (var i=0, strLen=str.length; strLen > i; i++) {
    bufView[i] = str.charCodeAt(i);
  }
  return buf;
}

function webPasswordToSymmetricKey(webpassword, callback) {
  //return bcrypt.genKey(PUBLIC_WEBPASSWORD_SALT)
}

function encryptVote(key, issue_id, choice_id, callback) {
  //https://coolaj86.com/articles/webcrypto-encrypt-and-decrypt-with-aes/
  // @issue_id is an integer (32bit)
  // @choice_id is an integer (32bit)

  //returns 16bytes (128 bits) encrypted in ECB mode
  // we use ECB mode because it is a single block
  // 32 bit IV + 32 bit CRC + issue_id + choice_id
  //key = str2ab('aaaabbbbccccdddd');
  data = str2ab('aaaabbbbccccdddd');
  crypto.subtle.encrypt(
    { name: 'AES-CBC', iv: str2ab('aaaa') }
    , key
    , data
  ).then(function (decrypted) {
    console.log(decrypted);
  })
  .catch(function(err) {
    console.log(err);
  })
}

function skytest() {

  var aesAlgorithmKeyGen = {
    name: "AES-CBC",
    // AesKeyGenParams
    length: 128
  };

  var aesAlgorithmEncrypt = {
    name: "AES-CBC",
    // AesCbcParams
    //iv: window.crypto.getRandomValues(new Uint8Array(16))
    iv: str2ab('aaaabbbbccccdddd') //INSECURE
  };

  // Create a key generator to produce a one-time-use AES key to encrypt some data
  window.crypto.subtle.generateKey(
    aesAlgorithmKeyGen, true, ["encrypt"])
    .then(
      function(aesKey) {
        window.sky2 = aesKey;
        return window.crypto.subtle.encrypt(
          aesAlgorithmEncrypt,
          aesKey,
          str2ab('aaaa')); //shortest output will be 16 bytes (upto 256)
      }
    ).then(
      function(ciphertext) {
        console.log("The ciphertext is: ", ciphertext);
        window.skycipher = ciphertext;
        window.xxx = new Uint8Array(ciphertext);
      }
    ).catch(
      function(err) {
        console.log(err);
      }
    );
}
