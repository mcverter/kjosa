var PUBLIC_WEBPASSWORD_SALT = '{{settings.VOTING_PUBLIC_SALT}}';


var str2ab = function(str) {
  var buf = new ArrayBuffer(str.length); // 2 bytes for each char
  var bufView = new Uint8Array(buf);
  for (var i=0, strLen=str.length; strLen > i; i++) {
    bufView[i] = str.charCodeAt(i);
  }
  return buf;
}

function webPasswordToSymmetricKey(webpassword, callback) {
  /*
    In python, identical to:
    import hashlib
    dk = hashlib.pbkdf2_hmac('sha256', webpassword.encode('utf8'),
                        PUBLIC_WEBPASSWORD_SALT.encode('utf8'), 5000)
    return [dk[i] for i in range(8)]
   */

  window.crypto.subtle.importKey(
    "raw", //only "raw" is allowed
    //window.crypto.getRandomValues(new Uint8Array(16)), //your password
    new TextEncoder("utf-8").encode(webpassword),
    {
        name: "PBKDF2",
    },
    true, //whether the key is extractable (i.e. can be used in exportKey)
    ["deriveKey", "deriveBits"] //can be any combination of "deriveKey" and "deriveBits"
  )
  .then(function(key){
      //returns a key object
      console.log('imported', key);
      window.crypto.subtle.deriveBits(
        {
          "name": "PBKDF2",
          //"salt": window.crypto.getRandomValues(new Uint8Array(16)),
          "salt": new TextEncoder("utf-8").encode(PUBLIC_WEBPASSWORD_SALT),
          "iterations": 5000,
          "hash": {name: "SHA-256"}, //can be "SHA-1", "SHA-256", "SHA-384", or "SHA-512"
        },
        key, //your key from generateKey or importKey
        64 //the number of bits you want to derive
      )
        .then(function(bits){
          //returns the derived bits as an ArrayBuffer
          var result = new Uint8Array(bits);
          console.log('bits 8bit', result);
          callback(result);
        })
   })
}

function encryptVote(key, issue_id, choice_id, callback) {
  //https://coolaj86.com/articles/webcrypto-encrypt-and-decrypt-with-aes/
  // @issue_id is an integer (32bit)
  // @choice_id is an integer (32bit)

  //returns 16bytes (128 bits) encrypted in ECB mode
  // we use ECB mode because it is a single block
  // 32 bit IV + 32 bit CRC + issue_id + choice_id
  //key = str2ab('aaaabbbbccccdddd');
  data = str2ab('aaaabbbbccccdddd');
  crypto.subtle.encrypt(
    { name: 'AES-CBC', iv: str2ab('aaaa') }
    , key
    , data
  ).then(function (decrypted) {
    console.log(decrypted);
  })
  .catch(function(err) {
    console.log(err);
  })
}

function skytest() {

  var aesAlgorithmKeyGen = {
    name: "AES-CBC",
    // AesKeyGenParams
    length: 128
  };

  var aesAlgorithmEncrypt = {
    name: "AES-CBC",
    // AesCbcParams
    //iv: window.crypto.getRandomValues(new Uint8Array(16))
    iv: str2ab('aaaabbbbccccdddd') //INSECURE
  };

  // Create a key generator to produce a one-time-use AES key to encrypt some data
  window.crypto.subtle.generateKey(
    aesAlgorithmKeyGen, true, ["encrypt"])
    .then(
      function(aesKey) {
        window.sky2 = aesKey;
        return window.crypto.subtle.encrypt(
          aesAlgorithmEncrypt,
          aesKey,
          str2ab('aaaa')); //shortest output will be 16 bytes (upto 256)
      }
    ).then(
      function(ciphertext) {
        console.log("The ciphertext is: ", ciphertext);
        window.skycipher = ciphertext;
        window.xxx = new Uint8Array(ciphertext);
      }
    ).catch(
      function(err) {
        console.log(err);
      }
    );
}

function skySpeckTest() {
  var expanded = [];
  //each elt in key is a 16-bit number
  var key = [0,0,0,50];
  expandKey(key, expanded); //alters expanded
  var text = [0,0];
  encrypt(text, expanded); //alters text
  return text;
  //will be: [4565, 26980] which is same as python's output
}

function encodeSpeckVote(webpassword, issue_id_, choice_id) {

}
