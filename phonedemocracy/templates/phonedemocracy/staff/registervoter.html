{% load staticfiles %}
<!doctype html>
<html>
  <head>
    <title>register voter</title>
    <link rel="stylesheet" href="{% static 'phonedemocracy/concise.min.css' %}"
          type="text/css" />
  </head>
  <body>
<form id="data-input">
  {{datainputform}}
</form>

<h2>Processed Info</h2>
<ul>
  <li id="name"></li>
  <li id="address"></li>
  <li id="phone"></li>
</ul>

<h2>Going to Server</h2>
<form id="server-ready" method="POST">
  {{form}}
  <input type="submit" value="Create Voter" />
  <input type="hidden" name="csrfmiddlewaretoken" value="{{ csrf_token }}" />
</form>

<script src="{% static 'phonedemocracy/node_modules/bcryptjs/dist/bcrypt.js' %}"></script>
<script src="{% static 'admin/js/vendor/jquery/jquery.min.js' %}"></script>
<script>
  {% include "phonedemocracy/jslib.html" %}

var homogenizeString = function(str) {
  return (str
    .toUpperCase()
    .replace(/\W+/g,' ') //no special chars
    .replace(/\s+/g,' ') //no extra spaces
    .replace(/^\s+/g,'') //no leading space
    .replace(/\s+$/g,'') //no trailing space
    );
};

var generatePhonePassword = function() {
  //TODO: make this use webcrypto and more robust (but still mnemonic)
  return parseInt(Math.random() * 10000)
  
}

var generatePhonePasswordHash = function(str_array, target) {
  //TODO: SHOULD BE AN HMAC (also on server)

  var str2encode = str_array.join('');
  console.log('to encode', str2encode);
  window.crypto.subtle.digest(
    {name: "SHA-256"},
    new Uint8Array(str2ab(str2encode)) //The data you want to hash as an ArrayBuffer
  )
    .then(function(hash){
      //returns the hash as an ArrayBuffer
      console.log(hash);
      var final_hash = '';
      var x = new Uint8Array(hash);
      for (v of x.values()) {
        var hex = v.toString(16);
        final_hash = (final_hash 
                      + ((hex.length == 2) ? hex : '0'+hex)
                     );
        //console.log(v, v.toString(16));
      }
      console.log('final hash', final_hash);
      target.value = final_hash;
      //console.log(x.map(function(c){String.fromCharCode(c)}));
    })
}

$('#id_phone_password').attr({'readonly':'readonly'}).val(generatePhonePassword());

$('#data-input').change(function() {
  var name = homogenizeString($('#id_full_name').val());
  var address = homogenizeString($('#id_address').val());
  var phone = ($('#id_phone').val()
               .replace(/\D+/g,'')
               .replace(/^\1?/,'+1')
              );


  $('#name').html(name);
  $('#address').html(address);
  $('#phone').html(phone);
  generatePhonePasswordHash(
    [phone, $('#id_phone_password').val()],
    $('#id_phone_pw_hash').get(0));
});



var sky = "foobar";
window.crypto.subtle.digest(
    {
        name: "SHA-256",
    },
    new Uint8Array(str2ab(sky)) //The data you want to hash as an ArrayBuffer
)
.then(function(hash){
    //returns the hash as an ArrayBuffer
    console.log(hash);
    var str = '';
    var x = new Uint8Array(hash);
    for (v of x.values()) {str=str+v.toString(16)}
    console.log("This is the same as `echo -n foobar |sha256sum` ")
    console.log(str);
    //console.log(x.map(function(c){String.fromCharCode(c)}));
})
//HMAC EXAMPLE
  window.crypto.subtle.generateKey(
    {
      name: "HMAC",
      hash: {name: "SHA-256"}, //can be "SHA-1", "SHA-256", "SHA-384", or "SHA-512"
  //length: 256, //optional, if you want your key length to differ from the hash function's block length
      length:128
    },
    true, //whether the key is extractable (i.e. can be used in exportKey)
    ["sign", "verify"] //can be any combination of "sign" and "verify"
  )
  .then(function(key){
    //returns a key object
    console.log(key);
    window.skykey = key;
  })
  .catch(function(err){
    console.error(err);
  });

  //hmac: secret='asdf1234' add 'x', add 'y'
  //   = afaa76dd3ae8b3467ef951147e0e8c51
  //  digest size:16
  //  blocksize: 64
  //  hmac-md5
  window.crypto.subtle.importKey(
    "jwk", //can be "jwk" or "raw"
    {   //this is an example jwk key, "raw" would be an ArrayBuffer
      kty: "oct",
      k: "Y0zt37HgOx-BY7SQjYVmrqhPkO44Ii2Jcb9yydUDPfE",
      alg: "HS256",
      ext: true,
    },
    {   //this is the algorithm options
      name: "HMAC",
      hash: {name: "SHA-256"}, //can be "SHA-1", "SHA-256", "SHA-384", or "SHA-512"
      //length: 256, //optional, if you want your key length to differ from the hash function's block length
    },
    false, //whether the key is extractable (i.e. can be used in exportKey)
    ["encrypt" //,"decrypt",
      //"sign", "verify"
    ] //can be any combination of "sign" and "verify"
  )
  .then(function(key){
    //returns the symmetric key
    console.log('cryptokeyimported', key);
    
  })
  .catch(function(err){
    console.error(err);
  });
</script>
  </body>
  </html>
